#ES2016_14353363
deadlock实验报告

本次实验整体并不难，但是需要根据自己的电脑不断调节参数以保证四所能够正常的产生。<br>
**本次试验报告并不是严格按照ppt中的要求格式编写，而是按照整个实验的思路以及流程，方便自己或者他人在不了解ppt内容的前体下了解本次实验。**

##代码阅读

![A&B](https://cloud.githubusercontent.com/assets/18045191/19834910/4619ea8e-9eaf-11e6-81b0-0fa6d2033ddc.png)

图中定义了两个类，并且方法类似，我只稍微分析一下class A，A中有两个方法函数
* `methodA`：该方法被`synchronized`修饰，也就意味着并发线程在同一时间内访问到这一个代码块的时候，只有一个线程能够得到执行调用一个。在它里面调用了一个对象B的last函数。
* `last`：该方同样被`synchronized`关键词修饰，也就说明该函数是不能够被多线程同时调度。它在这里输出了一行文字。

![Deadlock](https://cloud.githubusercontent.com/assets/18045191/19834950/a2977636-9eb0-11e6-94be-5fbff8c216b4.png)

我们看一下Deadlock的构造函数，首先new一个线程，接着开始运行new出来的线程调用start函数（此时跑的是run()里面的内容，调用资源B的methodB），接着系统计数10000次以后，主线程开始对调用资源A的的methodA。

将代码形式化就是如下流程

![Deadlock流程](https://cloud.githubusercontent.com/assets/18045191/19835054/704163b8-9eb5-11e6-89ae-9deeaae63009.png)

##死锁分析

代码读完了，我们就开始对死锁的产生进行实验分析。

操作系统的学习中我们已经知道，死锁的产生只会产生在并发线程中（*所以实验中会new一个子线程t出来*），并且具有以下特性：
> 1. **互斥**：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一个进程申请该资源，那么生情进程必须等到该资源被释放为止。实验中我们使用`synchronized`关键词修饰`资源A`和`资源B`中的方法，让其不能被同时运行，满足条件。

> 2. **占有并等待**：一个进程必须占有至少一个资源，并且等待一个资源，而该资源为其他进程所占有。我们在子线程跑起来之后，让其运行`methodB`，占有了`B资源`，然后让主线程调用`methodA`，占有了`A资源`**（注意此时子线程有可能已经释放了资`源B`）**。但是**假如在主线程在获得的`资源A`的`methodA`方法后，申请`资源B`的`last`函数时，子线程却还没有释放该`资源B`。**这时候，就是占有并且抢占。同理分析子线程亦然。

> 3. **非抢占**：资源不能够被抢占，即资源只能在进程完成任务后自动释放。**本实验中主线程与子线程的优先级相同，不会出现抢占的情况。所以非抢占满足。**

> 4. **循环等待**：若干进程之间形成一种头尾相接的循环等待资源关系。在**占有并等待中**我们已经发现该java代码有可能出现，**主线程获得资源A的同时申请资源B，子线程获得资源B的同时获得资源A**，这个时候就出现了循环等待的局面。

必须所有的4个条件同时满足才会出现死锁。

分析到了这里，我们其实可以看出来，整个实验最关键的地方其实是一定要保证两个线程中，当前线程拥有资源并且申请资源时，对方没有释放，整个实验就能够达到目的。

##运行实验

我们根据推论尝试一下实验（我们还不知道代码中的count进行延时的目的是什么）。

![Run Without Count](https://cloud.githubusercontent.com/assets/18045191/19835289/2633c570-9ebc-11e6-81c6-8a0c1ca5f13d.png)

100次迭代都运行完了，没有任何死锁的产生，并且每次都是主线程先行拿到资源A，然后又拿到资源B，输出b.last，释放之后，子线程才开始获取资源B，这中间没有占有并等待的过程，所以没有死锁的产生。

既然new一个子线程，然后运行start和run这个过程很费时间，导致子线程跟不上主线程的速度的话，我们是不是就可以让主线程等一等子线程？

这个时候就体现出来count的作用，它能够让主线程空运算一段时间之后再获取资源A申请资源B，这时候如果子线程拿到了资源B并且资源A，那么死锁就能够产生啦~~

![Count equals 10000](https://cloud.githubusercontent.com/assets/18045191/19835351/b75fe9a0-9ebe-11e6-82a3-c3ae79aff10d.png)

然鹅并没有什么L用，子线程还是太慢了（子线程此时表示你的CPU太慢怪我咯）

根据推论，慢慢的增加count的大小，如果能够让主线程和子线程能够同时运行的时候，就有可能产生思死锁了，也就是说，此时应该是a.last和b.last交替出现（因为有可能主线程领先一点点，有可能子线程领先一点点，但是两者进度差不多就行了）。

![Count equals 900000](https://cloud.githubusercontent.com/assets/18045191/19835372/73adbb78-9ebf-11e6-8780-ca39ae3d2307.png)

将count增加到900,000，子线程和主线程已经进度保持一致了，a.last和b.last交替出现，但是死锁依然并没有出现，就算迭代1000次都没有OTZ <br>
（子线程跳出来嘲讽脸：TA的count才10,000，你舍友20,000，你丫竟然要900,000才能赶上主线程，双十一去换台式吧 /:) 傲娇脸）

为什么明明子线程和主线程的进度已经一致了，然鹅还是没有死锁嘞？手动黑人问号脸

询问TA才知道，有可能是因为手握资源的时间太短了，CPU如果较慢的话，就会导致死锁没办法产生。解决办法就是增加资源的保持时间（在资源的method方法中再加count，让它在线程手里多赖一会）。

![method中添加count](https://cloud.githubusercontent.com/assets/18045191/19835431/2dae3dee-9ec1-11e6-98ce-f40e77eb6f7f.png)

这时候在重新编译运行，我们就能够很顺利的看见死锁啦
（第0, 2, 6, 7, 8, 10次均处于死锁状态），满屏幕的死锁扑面而来。本次是研圆满完成。